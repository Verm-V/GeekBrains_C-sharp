*[Назад](./../README.md)*  
  
### Задание для урока №1  
  
- [X] 1 Написать метод GetFullName(string firstName, string lastName, string patronymic), 
принимающий на вход ФИО в разных аргументах и возвращающий объединённую строку с ФИО. 
Используя метод, написать программу, выводящую в консоль 3–4 разных ФИО.  
- [X] 2 Написать программу, принимающую на вход строку — набор чисел, разделенных пробелом, 
и возвращающую число — сумму всех чисел в строке. Ввести данные с клавиатуры и вывести результат на экран.  
- [X] 3 Написать метод по определению времени года. На вход подаётся число – порядковый номер месяца. 
На выходе — значение из перечисления (enum) — Winter, Spring, Summer, Autumn. Написать метод, 
принимающий на вход значение из этого перечисления и возвращающий название времени года (зима, весна, лето, осень). 
Используя эти методы, ввести с клавиатуры номер месяца и вывести название времени года. 
Если введено некорректное число, вывести в консоль текст «Ошибка: введите число от 1 до 12».  
- [X] 4 (*) Написать программу, вычисляющую число Фибоначчи для заданного значения рекурсивным способом.  
  
---  
  
### Пояснения по выполнению задания  
  
1) Ничего необычного, только поменял местами firstName и lastName в методе.

2) Сначала хотел сделать простую конвертацию через Convert.ToSingle, 
предварительно проверив введеную строку, на то чтобы она содержала, 
только цифры, точки, минусы или пробелы и только в этом случае разбивать ее на подстроки  
Но как оказалось, программу можно уронить, введя что-нибудь вроде "--1" или "1.2.3", поэтому переделал 
сделал так, что строка проверяется не до разбивки, а уже после через парсинг каждого элемента, через TryParse, 
и если какой-то элемент не парсится, то сбрасывается флаг проверки isTextGood и строка снова запрашивается у пользователя.  

3) название месяца берется из readonly string массива, по номеру времени года через приведение перечисления со списком времен года.  

4) Сначала решил задачу стандартным методом, по формуле F(n) = F(n-1) + F(n-2) и обычной рекурсией, 
но такой метод очень медленный, т.к. гоняется кучу раз для каждого элемента.  
Уже на 40-м элементе последовательности, рассчет занимает секунд 10, на 43-м - более минуты, а 50-й придется ждать полчаса.  
Ну и я так подозреваю, где-то рядом можно и в переполнение стека уткнуться.  
Поэтому переделал метод на рекурсию с использованием памяти.  
Рассчет ведется только для тех элементов, которые не рассчитывались на предыдущих шагах.  
Для их хранеия используется массив, который передается в метод рассчета последовательности как параметр.  
Работает на порядок быстрее, на вычисление 93-го элемента уходи менее секунды.  
Хотя для этого метода нужна дополнительная память, но 'относительно' небольшая приблизительно 800 байт для 93-х элементов.  
Технически можно и тут переполнение стека вызовов поймать, но он по крайней мере не превышет того же количества элементов, т.е. маловероятно. 
(первый метод, с обычной рекурсией в коде так же оставил для наглядности)  
Максимальный номер элемента, ограничил числом 93, т.к. 94-й уже не влезет в используемый тип ulong и будет переполнение.  
  